start "start" = 
  "functions " _ func:Function {return func;}
/ "actions " _ typeAndId:MaybeTypeAndId  _ ":" _ action:Action
	{
		var a = action;
		a.id = typeAndId.id;
		a.slotType = typeAndId.type;
		return a;
	}
/ "nodes " _ node:Node {return node;}
/ "events " _ event:Event {return event;}
/ "structs " _ struct:Struct
	{
		return struct;
	}
Node =
	defOrVar:DefOrVar? _ typeAndId:MaybeTypeAndId _ 
		val:(Affect _ val:Val {return val;})? _
		slots:("(" _ "->" _ slots:Slots  _ ")" {return slots;})?
	{
		var node;
		if(val == null)
		{
			node = {
				type : typeAndId.type
			};
		}  else
		{
			node = {
				val : val
			};
			if(typeAndId.type != null)
				node.type = typeAndId.type;
		}
		if(defOrVar == null || defOrVar == "def")
		{
			node.def = typeAndId.id;
		}
		else
		{
			node.var = typeAndId.id;
		}
		if(slots != null)
		{
			node.slots = slots;
		}
		return node;
	}

Affect = ":" / "="

Event =
	cond:Val _ ":" _ action:Action
	{
		return {
			"when" : cond,
			"do" : action
		};
	}

Slots = IdList 

IdList = 
   head:Id _ tail:(_ "," _ (slot:Id) {return slot})* 
   {
      return [head].concat(tail);
   }

ParamsDecl =
	head:ParamDecl tail:( _ "," _ (p:ParamDecl) {return p})* {return [head].concat(tail);}
	
ParamDecl = 
	typeAndId:TypeAndId {return [ typeAndId.id, typeAndId.type];}

Affectation = 
	loc:("loc")? _ slot:VarOrDestructVar _ "=" _ val:Val 
    {
		var affect = 
		{
            "param": val,
            "slots": [slot],
            "type": "Send"
        };
		if(loc != null)
			affect.loc = true;
		return affect;
	}

VarOrDestructVar = 
	Var
	/ DestructVar
	
DestructVar = 
	"(" _ vars:Vars _ ")"
	{
		return {
			destruct : vars
		};
	}
	
Vars =  
	head:Var tail:( _ "," _ (struct:Var) {return struct})* 
	{
		return [head].concat(tail);
	}
	
DefOrVar = 
  "def"
  / "var"

Function =
	typeAndId:MaybeTypeAndId _ templates:("<" _ t:Templates _ ">" _ {return t;})? _
	"(" params:ParamsDecl ")" 
	_ body:
	(
		":" _ "(" _ nodes:(node:Node _ ","_ {return node;})* val:Val _ ")"
		{return {nodes : nodes, val : val};}
	)?
	{
		var func = {
			id : typeAndId.id, 
			in: params, 
			out : {
				type : typeAndId.type, 
			}
		};
		if(body != null)
		{
			func.nodes = body.nodes;
			func.out.val = body.val;
		}
		if(templates != null)
		{
			func.templates = templates;
		};
		if("type" in typeAndId)
		{
			func.type = typeAndId.type;
		}
		return func;
	}
	
TypeAndId =
  type:Type _ id:Id { return {type:type, id:id};}
 
MaybeTypeAndId =
  TypeAndId
  / id:Id {return {type:null, id:id};}

Type =
	base:Id _ templates:("<" _ t:Templates _ ">" _ {return t;})?
	{
		if(templates != null)
		{
			return {
				base : base,
				templates : templates
			}
		}
		return base
	}
	
Templates =  
	head:Type tail:( _ "," _ (type:Type) {return type})* 
	{
		return [head].concat(tail);
	}

lines = (_ v:Val _ LineTerminatorSequence {return v;})+

Structs =  
	head:Struct tail:( _ "," _ (struct:Struct) {return struct})* 
	{
		return [head].concat(tail);
	}
	
Struct = 
	_ id:Id  _ ":" _ "(" _ fieldsAndSubs:FieldsAndSubs _ ")"
	{
		return {
			name : id,
			fields : fieldsAndSubs.fields,
			subs : fieldsAndSubs.subs
		}
	}
	
FieldsAndSubs = 
	fields:FieldsDef _ subs:("," _ "subs" _ ":" _ "(" _ structs:Structs _ ")" {return structs;})?
	{
		return {
			fields : fields,
			subs : subs != null ? subs : []};
	}


FieldsDef =  
	head:FieldDef tail:( _ "," _ field:FieldDef {return field})* 
	{
		// le [].concat.apply(head, tail) effectue un flatten sur tail
		// car le deuxieme param de apply est la liste des arguments
		return [].concat.apply(head, tail);
	}
 
FieldDef = 
	!"subs" _ idList:IdList _ ":" _ type:Id
	{
		return idList.map(function(id){
			return [id, type];
		});
	}
	/ SlotDef
	
SlotDef = 
	_ "slot " _ id:Id _ params:("(" params:ParamsDecl ")" {return params;})? _ ":" action:Action
	{
		var slot = {
			slot : id,
			action : action,
			params : []
		};
		if(params != null)
		{
			slot.params = slot.params.concat(params);
		}
		return slot;
	}

Val =
   "true" {return true;}
  / "false" {return false;}
  / "[]" { return {array : []};}
  / Range
  / Comprehension 
  / Array 
  / Expression  
  / PrimaryExpression
  / Var
  / Message 
  / number 
  
  
Array = 
	"[" _ head:Val tail:( _ "," _ (i:Val) {return i})* _ "]"
	{
		return {
			array : [head].concat(tail)
		};
	}

Range = 
	"[" start:Int".." stop:Int"]" {
		return {
			"type" : "range",
			"params" : [start, stop]
		};
	}

Comprehension = 
	"[" _ val:Val _ "for " _ it:CompIterators _ when:("when " _ test:Val {return test})? _ "]" 
	{
		var res = {
			"comp" : val,
			"it" : it
		};
		if(when != null)
		{
			res["when"] = when;
		}
		return res;

	}

CompIterators = 
	head:CompIterator _ tail:( _ "," _ (i:CompIterator) {return i})* 
	{
		return [head].concat(tail);
	}
	
CompIterator = 
	it:IdOrDestructId _ index:("," _ i:Id {return i;})? _ "in " _ array:Val
	{
		var res = {
			"for" : it,
			"in" : array,
		}
		if(index != null)
		{
			res["index"] = index;
		}
		return res;
	}


IdOrDestructId = 
	Id
	/ DestructId
	
DestructId = 
	"(" _ ids:Ids _ ")"
	{
		return {
			destruct : ids
		};
	}
	
Ids = 
	head:Id _ tail:( _ "," _ (i:Id) {return i})* 
	{
		return [head].concat(tail);
	}

Actions "Actions" = 
   head:Action tail:( _ "," _ (i:Action) {return i})* {return [head].concat(tail);}

Action "Action" = 
  Affectation 
  / Foreach
  / SlotCall
  /  _ "(" _ actions:Actions _ ")" {return  {
			type : "Seq",
			slots : actions
		};}
  / IfAction 
  / "while" _ param:Expression  _ "do " _ action:Action _ 
	{
		return {
			while:param, 
			do:action};
	}  
  / id:Id _ val:("("_ Val? _ ")")? 
	{ 
		var action = {type : id};
		if(val[2] != undefined && val[2] !== "") action.param = val[2];
		return action;
	}

  
Foreach =
	_ "foreach " _ id:Var _ signal:Id _ params:("(" _ params:ExpressionList? _ ")" {return params})?
	{
		return {
			foreach : id,
			signal : signal,
			params : params != null ? params : []
		};
	}
  
SlotCall =
	_ id:Id _ path:StructPath _ "(" _ params:ExpressionList? _ ")" _
	{
		var varPath = [id].concat(path.slice(0, path.length - 1));
		return {
			signal : path.pop(),
			params : params != null ? params : [],
			var : varPath
		};
	}

Var = 
	start:Id subPath:(SubPath)?{
		var finalPath = [start];
		if(subPath != null)
			finalPath = finalPath.concat(subPath);
		return finalPath;
	}
	
IfAction =
	"if" _ param:Expression  _ "then" _ (":")? _ action:Action _ elseAction:("else" _ action:Action {return action;})?
	{
		var graph =
		{
			if:param, 
			then:action
		};
		if(elseAction != null)
		{
			graph["else"] = elseAction;
		}
		return graph;
	}

Params "params"
  =
  slot:Var _ "=" _ val:Expression  {return {
            "param": val,
            "slots": [slot],
            "type": "Send"
        };}
  / _ fields:FieldList {return {fields : fields};}
  / _ expr:ExpressionList {return {params : expr};} 
  / _ fields:FieldList _ "," expr:ExpressionList {return {params : expr, fields : fields};}

ExpressionList
 = headExpr:Val tailExpr:( _ "," _ (i:Val) {return i})* {return [headExpr].concat(tailExpr);}


FieldList
  = head:Field tail:( _ "," _ (f:Field) {return f})* 
    {
      var fields = {};
      fields[head[0]] = head[1];
      for(var i = 0; i < tail.length; i++) fields[tail[i][0]] = tail[i][1];
      return fields;
    }

Field
  = id:Id _ ":" _ val:AdditiveExpression {return [id, val];}

PrimaryExpression
  = "true" {return true;}
  / "false" {return false;}
  / FunctionCall
  / "(" __ expression:Expression __ ")" { return expression; }
  / array:( "[" __ (item:(Expression __ "," __) {return item[0];})* Expression __"]" ) { return [array[2].concat(array[3])]; }
  / number
  / v:Var { return v;}
  / String

FunctionCall = 
	id:Id _ "("_ params:(Params)? _ ")" 
	{	
		var func = {type : id};
		if(params != null)
		{
			if("params" in params) func["params"] = params["params"];
			if("fields" in params) func["fields"] = params["fields"];
		}
		return func;
	}
	
String = 
	"\"" text:[^"]* "\"" 
	{
		return {
			string : text.join("")};
	}

IfExpression = 
	_ "if " _ cond:Val _ "then " _ t:Val _ "else " _ e:Val
	{
		return {
          type:     "if",
          params : [cond, t, e]
        };
	}

Merge = 
	id:Var _ "\\" _ affectations:MergeAffectations
	{
		return {
			merge : id,
			with : affectations
		};
	}
		
MergeAffectations =
	head:MergeAffectation _ tail:( _ "\\" _ (i:MergeAffectation) {return i})* 
	{
		return [head].concat(tail);
	}
	
MergeAffectation = 
	"if " _ cond:Val _ "then " _ affectations:UncondAffectations _ elseAffectations:("else " _ affectation:UncondAffectations {return affectation})?
	{
		var aff = {
			"cond" : cond,
			"affectations" : affectations
		}
		
		if(elseAffectations != null)
		{
			aff["else"] = elseAffectations;
		}
		return aff;
	}
	/ UncondAffectation
	/ "(" _ aff:MergeAffectation _ ")" {return aff;}


UncondAffectations =
	head:UncondAffectation _ tail:( _ "," _ (i:UncondAffectation) {return i})* 
	{
		return [head].concat(tail);
	}
	
UncondAffectation =
	paths:MergePaths _ "=" _ val:Val
	{
		return {
			paths : paths,
			val : val
		};
	}
	
MergePaths = 
	head:Var _ tail:( _ "," _ (i:Var) {return i})* 
	{
		return [head].concat(tail);
	}

Match =
	"match " _ what:Val _ ":" _ "("_ cases:Cases elseCase:ElseCase _")"
	{
		return {
			match : what,
			cases : cases,
			else : elseCase
		}
	}

Cases =
	head:Case _ tail:( _ "," _ (i:Case) {return i})* 
	{
		return [head].concat(tail);
	}

Case =
	vals:Vals _ ":" _ out:Val
	{
		return {
			vals : vals, 
			out : out
		};
	}
	
ElseCase =
	(",")? _ "_" _ ":" _ out:Val
	{
		return out;
	}
	
Vals =
	head:Val _ tail:( _ "," _ (i:Val) {return i})* 
	{
		return [head].concat(tail);
	}

MatchType = 
	"type " _ id:Id _ ":" _ "(" _ matchCases:TypeCases _ ")" 
	{
		return {
			matchType : id,
			with : matchCases
		};
	}
		
TypeCases = 
	head:TypeCase _ tail:( _ "," _ (i:TypeCase) {return i})* 
	{
		return [head].concat(tail);
	}
	
TypeCase = 
	type:Id _ ":" _ val:Val
	{
		return {
			type : type,
			val : val
		}
	}

Let = "let" _ what:Nodes _ "in" _ val:Val
{
	return {
		let : what,
		in : val
	}
} 

Nodes = 
	head:Node _ tail:( _ "," _ (i:Node) {return i})* 
	{
		return [head].concat(tail);
	}

Message = 
	"<-" _ id:Id _ params:("(" _ params:ExpressionList _ ")" {return params})?
	{
		return {
			msg : id,
			params : params != null ? params :  []
		};
	}

Expression =
  IfExpression 
/ Let
/ Merge 
/ Match 
/ MatchType 
/ LogicalORExpression

Var = 
	start:Id subPath:(SubPath)?{
		var finalPath = [start];
		if(subPath != null)
			finalPath = finalPath.concat(subPath);
		return finalPath;
	}
  / Dereference
  
Id = 
	name:([a-zA-Z][a-zA-Z0-9_]*) { 
		return name.length == 1 ?
			name[0] :
			name[0] + name[1].join(""); 
	}
	
SubPath = 
	StructPath
	/ ArrayPath
	
StructPath =
	"." path:Id subPath:(SubPath)? {
		var finalPath = [path];
		if(subPath != null)
			finalPath = finalPath.concat(subPath);
		return finalPath;
	}
	
ArrayPath =
	"[" index:Val "]" subPath:(SubPath)? {
		var finalPath = [{index:index}];
		if(subPath != null)
			finalPath = finalPath.concat(subPath);
		return finalPath;
	}

Dereference =
  _ "*" _ id:Id {return "*" + id;}

UnaryExpression
  = PrimaryExpression
  / operator:UnaryOperator __ expression:UnaryExpression {
      return {
          type:     operator == "-" ? "neg" : operator,
          params : [expression]
      };
    }

UnaryOperator
  = "-"
  /  "!"

MultiplicativeExpression
  = head:UnaryExpression
    tail:(__ MultiplicativeOperator __ AdditiveExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     tail[i][1],
          params : [result, tail[i][3]]
        };
  
      }
      return result;
    }

MultiplicativeOperator
  = operator:("*" / "/" / "%") !"=" { return operator; }
  
AdditiveExpression
  =  head:MultiplicativeExpression
    tail:(__ AdditiveOperator __ AdditiveExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     tail[i][1],
          params : [result, tail[i][3]]
        };
      }
      return result;
    }

AdditiveOperator
  = "+" !("+" / "=") { return "+"; }
  / "-" !("-" / "=") { return "-"; }
 
ShiftExpression
  = head:AdditiveExpression
    tail:(__ ShiftOperator __ AdditiveExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     tail[i][1] == "<<" ? "LShift" : "RShift",
          params : [result, tail[i][3]]
        };
      }
      return result;
    }

ShiftOperator
  = "<<"
  / ">>"

RelationalExpression
  = head:ShiftExpression
    tail:(__ RelationalOperator __ ShiftExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     tail[i][1],
          params : [result, tail[i][3]]
        };
      }
      return result;
    }

RelationalOperator
  = "<="
  / ">="
  / "<"
  / ">"

EqualityExpression
  = head:RelationalExpression
    tail:(__ EqualityOperator __ RelationalExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     tail[i][1] == "==" ? "==" : "!=",
          params : [result, tail[i][3]]
        };
      }
      return result;
    }


EqualityOperator
  = "==="
  / "!=="
  / "=="
  / "!="

BitwiseANDExpression
  = head:EqualityExpression
    tail:(__ BitwiseANDOperator __ EqualityExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     "BinaryExpression",
          operator: tail[i][1],
          left:     result,
          right:    tail[i][3]
        };
      }
      return result;
    }


BitwiseANDOperator
  = "&" !("&" / "=") { return "&"; }

BitwiseXORExpression
  = head:BitwiseANDExpression
    tail:(__ BitwiseXOROperator __ BitwiseANDExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     "BinaryExpression",
          operator: tail[i][1],
          left:     result,
          right:    tail[i][3]
        };
      }
      return result;
    }

BitwiseXOROperator
  = "^" !("^" / "=") { return "^"; }

BitwiseORExpression
  = head:BitwiseXORExpression
    tail:(__ BitwiseOROperator __ BitwiseXORExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     "BinaryExpression",
          operator: tail[i][1],
          left:     result,
          right:    tail[i][3]
        };
      }
      return result;
    }


BitwiseOROperator
  = "|" !("|" / "=") { return "|"; }

LogicalANDExpression
  = head:BitwiseORExpression
    tail:(__ LogicalANDOperator __ BitwiseORExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     tail[i][1],
          params : [result, tail[i][3]]
        };
      }
      return result;
    }

LogicalANDOperator
  = "&&" !"=" { return "&&"; }

LogicalORExpression
  = head:LogicalANDExpression
    tail:(__ LogicalOROperator __ LogicalANDExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     tail[i][1],
          params : [result, tail[i][3]]
        };
      }
      return result;
    }

LogicalOROperator
  = "||" !"=" { return "||"; }

number "number"
  = literal:(HexIntegerLiteral / DecimalLiteral) {
      return literal;
    }

DecimalLiteral
  = parts:(SignedInteger"." DecimalDigits? ExponentPart?) {
      return parseFloat(parts.join(""));    }
  / parts:("." DecimalDigits ExponentPart?) { return parseFloat(parts.join("")); }
  / parts:(SignedInteger ExponentPart?) { return parseFloat(parts.join("")); }

Int = int:DecimalIntegerLiteral {return parseInt(int);}

DecimalIntegerLiteral
  = "0" / parts:(NonZeroDigit DecimalDigits?) {return parts.join("");}

DecimalDigits
  = d:DecimalDigit+ {return d.join("");}

DecimalDigit
  = [0-9]

NonZeroDigit
  = [1-9]

ExponentPart
  = ExponentIndicator SignedInteger

ExponentIndicator
  = [eE]

SignedInteger
  = parts:([-+]? DecimalDigits) {return parts.join("");}

HexIntegerLiteral
  = "0" [xX] digits:HexDigit+ { return parseInt("0x" + digits); }

HexDigit
  = [0-9a-fA-F]

IdentifierStart
  = "$"
  / "_"

_
  = (WhiteSpace)*

__
  = (WhiteSpace)*

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]
  / Zs

// Separator, Space
Zs = [\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]


LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator