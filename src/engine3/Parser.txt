{
    function makeFunctionCallExpression(func, args) {
        return {
            type : "FunctionCall",
            func : {
                type : "Id",
                name : func
            },
            args : args
        };
    }

    function makeInfixExpression(head, tail) {
        var result = makeFunctionCallExpression(tail[0].operator, [head, tail[0].operand]);
        for (var i = 1; i < tail.length; i++) {
            result = makeFunctionCallExpression(tail[i].operator, [result, tail[i].operand]);            
        };
        return result;
    }
}


start "start" =
    ___ head:ProgStatement ___ 
    tail:(
        (s:ProgStatement) 
        ___
        {return s}
    )* {
        return [head].concat(tail);
    }

/*  "functions " _ func:FunctionDeclaration {return func;}
/ "actions " _ slot:Slot
    {
        return slot
    }
/ "nodes " _ node:Node {return node;}
/ "events " _ event:Event {return event;}
/ "structs " _ struct:Struct
    {
        return struct;
    }*/

ProgStatement = 
    SlotDef
    / SignalDef
    / GenDef
    / ChainedConnection
    / Node
    / ClassDef

ClassDef = 
    ClassToken id:Id  typeParams:GenericParams params:ConstructorParams fields:ClassFields {
            return {
                type : "ClassDef",
                id : id,
                typeParams : typeParams,
                params : params,
                fields : fields
            };
        }

GenericParams =
    typeParams:("<" _ t:IdList _ ">" _ {return t;})? {
        return typeParams != null ? typeParams : []
    }

ConstructorParams =
    params:( 
        "(" ___ IndentToken
        head:ConstructorParam 
        tail:(
            LineSeparator
            param:ConstructorParam {
                return param;
            }
        )* 
        (
            ___ DedentToken ___ ")"
            / ")" ___ DedentToken
        ) _ {
            return [head].concat(tail);
        }
    )? {
        return params != null ? params : [];
    }

ConstructorParam =
    ClassVarDecl

ClassVarDecl =
    VarToken idType:IdType defaultVal:("=" _ val:Expression {return val;})?
    {
        return {
            type : "ClassVar",
            id : idType.id,
            defaultVal : defaultVal,
            explicitType : idType.type
        };
    }

ClassFields =
    fields:( 
        "{" ___ IndentToken
        head:ClassFieldDef 
        tail:(
            LineSeparator
            field:ClassFieldDef {
                return field;
            }
        )* 
        (
            ___ DedentToken ___ "}"
            / "}" ___ DedentToken
        ) _ {
            return [head].concat(tail);
        }
    )? {
        return fields != null ? fields : [];
    }

ClassFieldDef =
    DefDecl
    / SlotDef
    
IdType = 
    id:Id ":" _ type:Type {
        return {
            id : id,
            type : type
        };
    }

SlotDef =
    SlotToken _ id:Id _ params:ParamsDecl? _ "do" _ statement:Statement {
        return {
            type : "SlotDef",
            id : id,
            callType : params != null ? params.type : "",
            params : params != null ? params.params : [],
            statement : statement
        };
    }

SignalDef = 
    SignalToken _ id:Id type:("::" _ type:Type {return type;})? {
        return {
            type : "SignalDef",
            id : id,
            signalType : type
        };
    }

GenDef =
    GenToken _ id:Id _ params:ParamsDecl?  _ returnType:("::" _ type:Type {return type;})? _ "do" _ statement:Statement {
        return {
            type : "GenDef",
            id : id,
            callType : params != null ? params.type : "",
            params : params != null ? params.params : [],
            statement : statement,
            returnType : returnType
        };
    }

Node =
    DefDecl
    / VarDecl
    / NodeDef

DefDecl =
    DefToken _ maybeTypeAndId:MaybeTypeAndId _ "=" _ val:Expression
    {
        return {
            type : "Def",
            id : maybeTypeAndId.id,
            val : val,
            explicitType : maybeTypeAndId.type
        };
    }

VarDecl = 
    VarToken _ maybeTypeAndId:MaybeTypeAndId _  val:("=" _ val:Expression {return val;})?
    {
        return {
            type : "Var",
            id : maybeTypeAndId.id,
            val : val,
            explicitType : maybeTypeAndId.type
        };
    }
    
NodeDef = 
    NodeDefToken maybeTypeAndId:MaybeTypeAndId 
        "=" _ NewToken "{" 
        ___ IndentToken 
        head:NodeField
        tail:(LineSeparator field:NodeField {return field})* 
        ___ DedentToken ___ "}" {
            return {
                type : "NodeDef",
                id : maybeTypeAndId.id,
                fields : [head].concat(tail)
            };
        }

NodeField =
    NodeMemberDef
    
NodeMemberDef =
    DefDecl
    / VarDecl

ChainedConnection =
    signal:Id _ links:Link+ {
        return {
            type : "ChainedConnection",
            signal : signal,
            links : links
        }
    }

Link =
    "~>" _ link:Id {
        return link;
    }

Type = 
    GenericInstance
    / Id

ConditionalExpression = 
    _ "if" _ test:Comprehension _ "then" _ consequent:Comprehension _ "else " _ alternate:Comprehension
    {
        return{
            type : "ConditionalExpression",
            test: test,
            consequent : consequent,
            alternate : alternate
        };
    }
    / Comprehension

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions /////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

Expression =
    FunctionCall
    / NonCallExpression

NonCallExpression =
    AdditiveExpression
    / ListComprehensionExpression
    / ListExpression
    / TupleExpression

ListComprehensionExpression = 
    "[" _ elt:Expression _ generators:Comprehension+ "]" {
        return {
            type : "ListComprehensionExpression",
            elt : elt,
            generators : generators
        }
    }

Comprehension = 
    "for" _ targets:IdList _ "in" _ iter:Expression _ conditions:Condition* _ {
        return {
            type : "Generator",
            targets : targets,
            iter : iter,
            conditions : conditions
        }
    }

Condition = 
    "if" _ condition:Expression {
        return condition;
    }

ListExpression = 
    "[" _ head:Expression tail:( _ "," _ (i:Expression) {return i})* _ "]" {
        return {
            type : "ListExpression",
            array : [head].concat(tail)
        };
    }

TupleExpression = 
    "(" _ 
    head:Expression
    tail:("," _ (i:Expression) {return i})+ 
    ")" _ {
        return {
            type : "TupleExpression",
            tuple : [head].concat(tail)
        };
    }

AdditiveExpression =
    head:MultiplicativeExpression _ tail:(operator:AdditiveOperator _ operand:MultiplicativeExpression _ {
        return {
            operator: operator,
            operand: operand
        };
    })+ {
        return makeInfixExpression(head, tail);
    }
    / MultiplicativeExpression

AdditiveOperator =
    "+" !("=") { return "+"; }
    / "-" !("=") { return "-"; }

// This one shortcut most expression for faster testing

MultiplicativeOperator =
    operator:("*" / "/" / "%") !"=" { return operator; }

// The real one, replace previous one for delivery
MultiplicativeExpression = 
    head:LogicalORExpression _ tail:(operator:MultiplicativeOperator _ operand:LogicalORExpression _ {
        return {
            operator: operator,
            operand: operand
        };
    } )+ {
        return makeInfixExpression(head, tail);
    }
    / LogicalORExpression


LogicalORExpression =
    head:LogicalANDExpression _ tail:(operator:LogicalOROperator _ operand:LogicalANDExpression _ {
        return {
            operator: operator,
            operand: operand
        };
    })+ {
        return makeInfixExpression(head, tail);
    }
    / LogicalANDExpression

LogicalOROperator
  = "or" { return "or"; }

LogicalANDExpression =
    head:EqualityExpression _ tail:(operator:LogicalANDOperator _ operand:EqualityExpression _ {
        return {
            operator: operator,
            operand: operand
        };
    })+ {
        return makeInfixExpression(head, tail);
    }
    / EqualityExpression

LogicalANDOperator
  = "and" { return "and"; }

// BitwiseORExpression =
//  head:BitwiseXORExpression _ tail:(operator:BitwiseOROperator _ operand:BitwiseXORExpression _ {
//         return {
//             operator: operator,
//             operand: operand
//         };
//     })+ {
//         return makeInfixExpression(head, tail);
//     }
//  / BitwiseXORExpression

// BitwiseOROperator
//   = "|" !("|" / "=") { return "|"; }

// BitwiseXORExpression =
//  head:BitwiseANDExpression _ tail:(operator:BitwiseXOROperator _ operand:BitwiseANDExpression _ {
//         return {
//             operator: operator,
//             operand: operand
//         };
//     })+ {
//         return makeInfixExpression(head, tail);
//     }
//  / BitwiseANDExpression

// BitwiseXOROperator
//   = "^" !("^" / "=") { return "^"; }

// BitwiseANDExpression =
//  head:EqualityExpression _ tail:(operator:BitwiseANDOperator _ operand:EqualityExpression _ {
//         return {
//             operator: operator,
//             operand: operand
//         };
//     })+ {
//         return makeInfixExpression(head, tail);
//     }
//  / EqualityExpression

// BitwiseANDOperator
//   = "&" !("&" / "=") { return "&"; }

// ShiftExpression =
//  head:UnaryExpression _ tail:(operator:ShiftOperator _ operand:UnaryExpression _ {
//         return {
//             operator: operator,
//             operand: operand
//         };
//     })+ {
//         return makeInfixExpression(head, tail);
//     }
//  / UnaryExpression   

// ShiftOperator
//   = "<<"
//   / ">>"

EqualityExpression =
    head:RelationalExpression _ tail:(operator:EqualityOperator _ operand:RelationalExpression _ {
        return {
            operator: operator,
            operand: operand
        };
    })+ {
        return makeInfixExpression(head, tail);
    }
    / RelationalExpression

EqualityOperator =
    "=="
    / "!="

RelationalExpression =
    head:UnaryExpression _ tail:(operator:RelationalOperator _ operand:UnaryExpression _ {
        return {
            operator: operator,
            operand: operand
        };
    })+ {
        return makeInfixExpression(head, tail);
    }
    / UnaryExpression

RelationalOperator
  = "<="
  / ">="
  / "<"
  / ">"

UnaryExpression = 
    operator:UnaryOperator _ expression:UnaryExpression {
        return makeFunctionCallExpression(operator, [expression]);
    }
    / ChainedMemberExpression

UnaryOperator
    = "negate"
    /  "not"

FunctionCall =
    func:Callable _ args:FuncArgs {
        return{
            type : "FunctionCall",
            func : func,
            args : args
        };
    }

Callable =
    ChainedMemberExpression
    / Atom
    / "(" _ exp:Expression _ ")" _ {return exp;}

FuncArgs =
    LineSeparator IndentToken _ head:NonCallExpression tail:(LineSeparator e:NonCallExpression {return e})* ___ DedentToken {
        return [head].concat(tail);
    }
    / head:NonCallExpression _ tail:((i:NonCallExpression) _ {return i})* {
        return [head].concat(tail);
    }

ChainedMemberExpression =
    head:MemberHead _ operations:(MemberExpression)+ {
        var result = operations[0];
        result[
            (result.type === "MemberExpression") ? 
                "obj" :
                "func"
        ] = head;
        for (var i = 1; i < operations.length; i++) {
            var operation = operations[i];
            operation[
                (operation.type === "MemberExpression") ? 
                    "obj" :
                    "func"
            ] = result;
            result = operation;
        }
        return result 
    }
    / NewExpression

NewExpression =
    NewToken klass:Id args:TupleArgs
    {
        return {
            type : "NewExpression",
            "class" : klass,
            args : args
        };
    }
    / Atom

TupleArgs =
    "(" _ 
    args:(
        head:Expression
        tail:("," _ (e:Expression) {return e})*
        {return [head].concat(tail);}
    )?
    ")" {
        return args != null ? args : [];
    }

MemberHead = 
    Atom
    / "(" _ exp:Expression _ ")" _ {return exp;}

MemberExpression =
    "." _ field:Id _ {
        return {
            type: "MemberExpression",
            /*obj: obj,*/
            field: field
        };
    }

ExpressionList = 
    head:Expression tailExpr:( _ "," _ (i:Expression) {return i})*
    {
        return [head].concat(tailExpr);
    }

Atom =
    Literal
    / GenericInstance
    / Id
    / TupleExpression
    / "(" _ expr:Expression _ ")" _ {return expr;}

GenericInstance = 
    base:Id _ "<" _ args:IdList _ ">" _
    {
        return {
            type : "GenericInstance",
            base : base.name,
            args : args
        }
    }

Literal =
    BooleanLiteral
    / StringLiteral
    / Number

BooleanLiteral =
    "true" !IdentifierPart {
        return {
            type : "BooleanLiteral",
            val : true
        }
    }
    / "false" !IdentifierPart {
        return {
            type : "BooleanLiteral",
            val : false
        }
    }

StringLiteral = 
    "\"" text:([^"\\] / dq:('\\' c:. {return c;}))* "\"" {
        return {
            type : "StringLiteral",
            val : text.join("")
        };
    }

Id = 
    !ReservedWord name:([a-zA-Z_][a-zA-Z0-9_]*) _ { 
        return {
            type : "Id",
            name : name.length == 1 ?
                name[0] :
                name[0] + name[1].join("")
        };
    }

IdentifierStart
  = [a-zA-Z_]
  / "$"
  / "_"
  // / "\\" sequence:UnicodeEscapeSequence { return sequence; }

IdentifierPart
  = IdentifierStart
  / UnicodeCombiningMark
  / UnicodeDigit
  / "\u200C" { return "\u200C"; } // zero-width non-joiner
  / "\u200D" { return "\u200D"; } // zero-width joiner

UnicodeCombiningMark
  = Mn
  / Mc

UnicodeDigit
  = Nd

ReservedWord
  = Keyword
  / FutureReservedWord
  / BooleanLiteral

Keyword
  = (
        "break"
      / "case"
      / "catch"
      / "continue"
      / "debugger"
      / "default"
      / "delete"
      / "do"
      / "else"
      / "finally"
      / "for"
      / "function"
      / "if"
      / "instanceof"
      / "in"
      / "new"
      / "return"
      / "switch"
      / "this"
      / "throw"
      / "try"
      / "typeof"
      / "def"
      / "var"
      / "node"
      / "slot"
      / "signal"
      / "gen"
      / "slot"
      / "void"
      / "while"
      / "with"
      / "$>"
      / "$<"
    )
    !IdentifierPart

FutureReservedWord
  = (
        "class"
      / "const"
      / "enum"
      / "export"
      / "extends"
      / "import"
      / "super"
    )
    !IdentifierPart

BooleanLiteral
  = TrueToken  { return { type: "BooleanLiteral", value: true  }; }
  / FalseToken { return { type: "BooleanLiteral", value: false }; }

TrueToken       = "true"             !IdentifierPart _
TryToken        = "try"              !IdentifierPart _
FalseToken      = "false"            !IdentifierPart _
SignalToken     = "signal"           !IdentifierPart _
SlotToken       = "slot"             !IdentifierPart _
ClassToken       = "class"             !IdentifierPart _
ReturnToken     = "return"           !IdentifierPart _
GenToken        = "gen"              !IdentifierPart _
DefToken        = "def"              !IdentifierPart _
NodeDefToken        = "node"              !IdentifierPart _
NewToken        = "new"              !IdentifierPart _
VarToken        = "var"              !IdentifierPart _
IndentToken        = "$>"               _
DedentToken        = "$<"               _
UnitToken       = "()"              !IdentifierPart _

// UnicodeEscapeSequence
//   = "u" digits:$(HexDigit HexDigit HexDigit HexDigit) {
//       return String.fromCharCode(parseInt("0x" + digits));
//     }

/*********************************************************************************************/
/*********************************************************************************************/
// End expressions ////////////////////////////////////////////////////////////////////////////
/*********************************************************************************************/
/*********************************************************************************************/
    
Event =
    condition:Expression _ statement:Statement{
        return {
            type : "Event",
            condition : condition,
            statement : statement
        };
    }

Assignment = 
    local:(VarToken)? _ target:AssignmentTarget _ "=" _ value:Expression 
    {
        return {
            type : "Assignment",
            target : target,
            value : value,
            local : local != null
        };
    }

AssignmentTarget =
    ChainedMemberExpression
    / Id

DestructAssignment = 
    local:("var")? _ targets:IdList _ "=" _ value:Expression 
    {
        return {
            type : "DestructAssignment",
            targets : targets,
            value : value,
            local : local != null
        };
    }

AccessAssignment = 
    _ slot:Expression _ "[" _ indexOrKey:Expression _ "]" _ "=" _ val:Expression 
    {
        var affect = 
        {
            "accessSet": val,
            "slots": [slot],
            indexOrKey : indexOrKey
        };
        return affect;
    }
    
FunctionDeclaration =
    id:Id _ typeParams:GenericParams _
       params:ParamsDecl _ returnType:("::" _ type:Type _ {return type})? _ body:( "=" _ e:Expression {return e;})?
    {
        return {
            type : "FunctionDeclaration",
            id : id,
            callType : params.type,
            params : params.params, 
            body : body,
            typeParams : typeParams,
            returnType : returnType
        };
    }

ParamsDecl =
    params:CurriedParamsDecl {
        return {
            type : "Curried",
            params : params
        };
    }
    / params:TupleParamsDecl {
        return {
            type : "Tuple",
            params : params
        };
    }

CurriedParamsDecl =
    params:CurriedParamDecl+ {
        return params;
    }

CurriedParamDecl = 
    TypedCurriedParamDecl
    / UntypedCurriedParamDecl

TypedCurriedParamDecl =
    id:Id _ ":" _ type:Type _ {
        return {
            type : type,
            id : id
        };
    }

UntypedCurriedParamDecl =
    id:Id _ {
        return {
            type : "",
            id : id
        };
    }

TupleParamsDecl =
    "(" _ params:(TupleParams)? _ ")" _ {
        return params != null ? params : [];
    }

TupleParams =
    head:TupleParam
    tail:("," _ (p:TupleParam) {return p})* {
        return [head].concat(tail);
    }

TupleParam = 
    id:Id _ ":" _ type:Type _ {
        return {
            type : type,
            id : id
        };
    }
    / id:Id _ {
        return {
            type : null,
            id : id
        };
    }

Structs =  
    head:Struct tail:( _ "," _ (struct:Struct) {return struct})* 
    {
        return [head].concat(tail);
    }
    
Struct = 
    _ id:Id _ typeParams:GenericParams _ fieldsAndSubs:("(" _ fieldsAndSubs:FieldsAndSubs _ ")" {return fieldsAndSubs;})? {
        return {
            id : id,
            fields : fieldsAndSubs != null ? fieldsAndSubs.fields : [],
            subs : fieldsAndSubs != null ? fieldsAndSubs.subs : [],
            typeParams : typeParams
        };
    }
    
FieldsAndSubs = 
    fields:FieldsDef _ subs:("," _ "subs" _ "(" _ structs:Structs _ ")" {return structs;})?
    {
        return {
            fields : fields,
            subs : subs != null ? subs : []
        };
    }
    / _ "subs" _ "(" _ structs:Structs _ ")"
    {
        return {
            fields : [],
            subs : structs
        };
    }

FieldsDef =  
    head:FieldDef tail:( _ "," _ field:FieldDef {return field})* 
    {
        // le [].concat.apply(head, tail) effectue un flatten sur tail
        // car le deuxieme param de apply est la liste des arguments
        //return [].concat.apply(head, tail);
        return [head].concat(tail);

    }

FieldDef = 
    "slot " slot:SlotDef {
        return slot
    }
    / SignalDef
    / !"subs" _ type:Type _ id:Id _  {
        return {
            type : "Property",
            id : id,
            varType : type
        };
    }
    
Closure = 
    params:MaybeTypeAndIds _ "->" _ val:Expression
    {
        return{
            "closure" : val,
            "params" : params
        };
    }

MaybeTypeAndIds =
    head:MaybeTypeAndId tail:( _ "," _ (type:MaybeTypeAndId) {return type})* 
    {
        return [head].concat(tail);
    }

MaybeTypeAndId =
    type:Type _ id:Id
    {
        return {
            id : id,
            type : type
        }
    }
    / id:Id
    {
        return {
             id:id,
             type:null
        };
    }


Dict = 
    "{" _ head:DictEntry? tail:( _ "," _ (i:DictEntry) {return i})* _ "}"
    {
        var val = {};
        if(head)
        {
            val[head[0]] = head[1];
            for(var i = 0; i < tail.length; i++)
            {
                val[tail[i][0]] = tail[i][1];
            }
        }
        
        return {
            dict : val
        };
    }

DictEntry = 
    id:Id _ ":" _ val:Expression
    {
        return [id, val]
    }

Range = 
    "[" start:DecimalIntegerLiteral".." stop:DecimalIntegerLiteral"]" {
        return {
            "type" : "range",
            "params" : [start, stop]
        };
    }

IdOrDestructId = 
    Id
    / DestructId
    
DestructId = 
    "(" _ ids:IdList _ ")" {
        return {
            destruct : ids
        };
    }
    
IdList = 
    head:Id _ tail:( _ "," _ (i:Id) {return i})* {
        return [head].concat(tail);
    }


Statement "Statement" = 
    StatementBlock
    / Assignment 
    / ReturnStatement
    / DestructAssignment 
    / AccessAssignment
    / Foreach
    / ForStatement
    / MatchStatement
    / MatchTypeStatement
    / SignalSending
    / Update
    / IfStatement 
    / "while" _ param:Expression  _ "do" _ action:Statement _ 
    {
        return {
            while:param, 
            do:action};
    }  
    / "(" _ statement:Statement _ ")" _ {return statement;}

StatementBlock "StatementBlock" = 
    ___ IndentToken 
    head:Statement 
    tail:(
        LineSeparator 
        statement:Statement {return statement}
    )*
    ___ DedentToken {
        return {
            type : "StatementBlock",
            statements : [head].concat(tail)
        };
    }

ReturnStatement =
    ReturnToken _ val:Expression {
        return {
            type : "ReturnStatement",
            val : val
        };
    }

ForStatement =
    _ "for" _ it:IdOrDestructId _ index:("," _ i:Id {return i;})? _ "in" _ 
    array:Expression _ "do" _ action:Statement
    {
        var res =  {
            "for" : it,
            "in" : array,
            "do" : action
        };
        if(index != null)
        {
            res["index"] = index;
        };
        return res;
    }
    
MatchStatement =
    "match" _ what:Expression _ "do" _ "("_ cases:StatementCases elseCase:ElseStatementCase? _")"
    {
        var ret = {
            match : what,
            cases : cases
        };
        if(elseCase)
        {
            ret.else = elseCase;
        }
        return ret;
    }

StatementCases =
    head:StatementCase _ tail:( _ "," _ (i:StatementCase) {return i})* 
    {
        return [head].concat(tail);
    }

StatementCase =
    vals:Vals _ "=>" _ action:Statement
    {
        return {
            vals : vals, 
            action : action
        };
    }

ElseStatementCase =
    (",")? _ "_" _ "=>" _ action:Statement
    {
        return action;
    }

MatchTypeStatement = 
    "type" _ id:Expression _ "do" _ "(" _ matchCases:TypeStatementCases _ ")" 
    {
        return {
            matchType : id,
            cases : matchCases
        };
    }
        
TypeStatementCases = 
    head:TypeStatementCase _ tail:( _ "," _ (i:TypeStatementCase) {return i})* 
    {
        return [head].concat(tail);
    }
    
TypeStatementCase = 
    type:Id _ "=>" _ action:Statement
    {
        return {
            type : type,
            action : action
        }
    }

Update =
    "update" _ it:IdOrDestructId _ index:("," _ i:Id {return i;})? _ "in" _ array:Expression _
    "with" _ val:ValOrCondUpdate _ filter:("filter " _ test:Expression {return test})?
    {
        var res = {
            "update" : it,
            "in" : array            
        }
        if("cond" in val)
        {
            res["condWith"] = val.cond;
        }
        else
        {
            res["with"] = val.val;
        }
        if(index != null)
        {
            res["index"] = index;
        }
        if(filter != null)
        {
            res["filter"] = filter;
        }
        return res;
    }

ValOrCondUpdate =
    cond:CondUpdate {return {cond : cond};}
    / val:Expression {return {val : val};}

CondUpdate =
    _ val:Expression _ "if" _ cond:Expression 
    {
        return {
            "val" : val,
            "if" : cond
        };
    }
    
Foreach =
    _ "foreach " _ id:Expression _ signal:Id _ params:("(" _ params:ExpressionList? _ ")" {return params})?
    {
        return {
            foreach : id,
            signal : signal,
            params : params != null ? params : []
        };
    }

SignalSending =
    slot:Callable 
    args:(
        // Either has 
        args:NonCallExpression+ {return args;}
        / UnitToken {return [];}
    ) {
        return{
            type : "SignalSending",
            slot : slot,
            args : args
        };
    }

SignalArgs =
    args:NonCallExpression+
    {
        return args;
    }

/*SlotCall = 
    id:Id _ path:StructPath _ "(" _ params:ExpressionList? _ ")" _ {
        var varPath = [id].concat(path.slice(0, path.length - 1));
        return {
            type : "Signal",
            slot : path.pop(),
            params : params != null ? params : [],
            var : varPath
        };
    }
    
StructPath =
    "." path:Id subPath:(StructPath)? {
        var finalPath = [path];
        if(subPath != null)
            finalPath = finalPath.concat(subPath);
        return finalPath;
    }

ChainedSlotCall =
    head:Expression _ operations:(ChainedReference)* _ args:ExpressionList? _ {
        var result = head;
        for (var i = 0; i < operations.length; i++) {
            var operation = operations[i];
            operation["obj"] = result;
            result = operation;
        }
        result = {
            type : "Signal",
            slot : result,
            args : args != null ? args : []
        };
        return result 
    }

ChainedReference =
    MemberReference

MemberReference =
    "." _ field:Id _ {
        return {
            type: "MemberReference",
            field: field
        };
    }*/
  
IfStatement =
    "if" _ param:Expression  _ "then" _ action:Statement _ elseStatement:("else" _ action:Statement {return action;})?
    {
        var graph =
        {
            if:param, 
            then:action
        };
        if(elseStatement != null)
        {
            graph["else"] = elseStatement;
        }
        return graph;
    }

FieldList
  = head:Field tail:( _ "," _ (f:Field) {return f})* 
    {
      var fields = {};
      fields[head[0]] = head[1];
      for(var i = 0; i < tail.length; i++) fields[tail[i][0]] = tail[i][1];
      return fields;
    }

Field =
    id:Id _ ":" _ val:Expression {
        return {
            id : id,
            val : val
        };
    }

ArrayDictAccess =
    _ id:Expression _ "[" _ indexOrKey:Expression _ "]" _
    {
        return {
            access: id,
            indexOrKey : indexOrKey
        };
    }

Merge = 
    id:Expression _ "\\" _ affectations:MergeAssignments
    {
        return {
            merge : id,
            with : affectations
        };
    }
        
MergeAssignments =
    head:MergeAssignment _ tail:( _ "\\" _ (i:MergeAssignment) {return i})* 
    {
        return [head].concat(tail);
    }
    
MergeAssignment = 
    "if " _ cond:Expression _ "then " _ affectations:UncondAssignments _ elseAssignments:("else " _ affectation:UncondAssignments {return affectation})?
    {
        var aff = {
            "cond" : cond,
            "affectations" : affectations
        }
        
        if(elseAssignments != null)
        {
            aff["else"] = elseAssignments;
        }
        return aff;
    }
    / UncondAssignment
    / "(" _ aff:MergeAssignment _ ")" {return aff;}

UncondAssignments =
    head:UncondAssignment _ tail:( _ "," _ (i:UncondAssignment) {return i})* 
    {
        return [head].concat(tail);
    }
    
UncondAssignment =
    paths:MergePaths _ "=" _ val:Expression
    {
        return {
            paths : paths,
            val : val
        };
    }
    
MergePaths = 
    head:Expression _ tail:( _ "," _ (i:Expression) {return i})* 
    {
        return [head].concat(tail);
    }

Match =
    "match" _ what:Expression _ "("_ cases:Cases elseCase:ElseCase _")"
    {
        return {
            match : what,
            cases : cases,
            else : elseCase
        }
    }

Cases =
    head:Case _ tail:( _ "," _ (i:Case) {return i})* 
    {
        return [head].concat(tail);
    }

Case =
    vals:Vals _ ":" _ out:Expression
    {
        return {
            vals : vals, 
            out : out
        };
    }
    
ElseCase =
    (",")? _ "_" _ ":" _ out:Expression
    {
        return out;
    }
    
Vals =
    !("_"!Id) head:Expression _ tail:( _ "," _ (i:Expression) {return i})* 
    {
        return [head].concat(tail);
    }

MatchType = 
    "type" _ id:Id _ "(" _ matchCases:TypeCases _ ")" 
    {
        return {
            matchType : id,
            cases : matchCases
        };
    }
        
TypeCases = 
    head:TypeCase _ tail:( _ "," _ (i:TypeCase) {return i})* 
    {
        return [head].concat(tail);
    }
    
TypeCase = 
    type:Type _ ":" _ val:Expression
    {
        return {
            type : type,
            val : val
        }
    }

Let = "let" _ what:OneOrMoreNode  _ "in" _ val:Expression
{
    return {
        let : what,
        in : val
    }
} 

OneOrMoreNode =
    node:Node {return [node]}
    / "(" _ nodes:Nodes _ ")" {return nodes;}

Nodes = 
    head:Node _ tail:( _ "," _ (i:Node) {return i})* 
    {
        return [head].concat(tail);
    }


Number "Number" =
    literal:(HexIntegerLiteral / DecimalLiteral / DecimalIntegerLiteral) {
        return literal;
    }

DecimalLiteral = 
    parts:(SignedInteger"." DecimalDigits? ExponentPart?) {
        return {
            type : "FloatLiteral",
            val : parseFloat(parts.join(""))
        };
    }
    / parts:("." DecimalDigits ExponentPart?) {
        return {
            type : "FloatLiteral",
            val : parseFloat(parts.join(""))
        };
    }
    / parts:(SignedInteger ExponentPart) {
        return {
            type : "FloatLiteral",
            val : parseFloat(parts.join(""))
        }
    }

DecimalIntegerLiteral = 
    int:SignedInteger _
    {
        return {
            type : "IntLiteral",
            val : parseInt(int)
        }
    }

DecimalDigits
  = d:DecimalDigit+ {return d.join("");}

DecimalDigit
  = [0-9]

NonZeroDigit
  = [1-9]

ExponentPart =
    ExponentIndicator exp:SignedInteger
    {
        return "e" + exp;
    }

ExponentIndicator
  = [eE]

SignedInteger = 
    parts:([-+]? DecimalDigits) {return parts.join("");}

HexIntegerLiteral
  = "0" [xX] digits:HexDigit+ _ { return parseInt("0x" + digits); }

HexDigit
  = [0-9a-fA-F]

_ = 
    (WhiteSpace / Comment)*
    // (WhiteSpace / LineTerminatorSequence / Comment)*

___ = 
    (WhiteSpace / LineTerminatorSequence / Comment)*
    // (WhiteSpace / LineTerminatorSequence / ";" / Comment)*

Comment =
    "#" (!LineTerminator SourceCharacter)*
__
  = (WhiteSpace)*

SourceCharacter
  = .

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]
  / Zs

// Separator, Space
Zs = [\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000]

// Mark, Spacing Combining
Mc = [\u0903\u093E\u093F\u0940\u0949\u094A\u094B\u094C\u0982\u0983\u09BE\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E\u0A3F\u0A40\u0A83\u0ABE\u0ABF\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6\u0BC7\u0BC8\u0BCA\u0BCB\u0BCC\u0BD7\u0C01\u0C02\u0C03\u0C41\u0C42\u0C43\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC2\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E\u0D3F\u0D40\u0D46\u0D47\u0D48\u0D4A\u0D4B\u0D4C\u0D57\u0D82\u0D83\u0DCF\u0DD0\u0DD1\u0DD8\u0DD9\u0DDA\u0DDB\u0DDC\u0DDD\u0DDE\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062\u1063\u1064\u1067\u1068\u1069\u106A\u106B\u106C\u106D\u1083\u1084\u1087\u1088\u1089\u108A\u108B\u108C\u108F\u17B6\u17BE\u17BF\u17C0\u17C1\u17C2\u17C3\u17C4\u17C5\u17C7\u17C8\u1923\u1924\u1925\u1926\u1929\u192A\u192B\u1930\u1931\u1933\u1934\u1935\u1936\u1937\u1938\u19B0\u19B1\u19B2\u19B3\u19B4\u19B5\u19B6\u19B7\u19B8\u19B9\u19BA\u19BB\u19BC\u19BD\u19BE\u19BF\u19C0\u19C8\u19C9\u1A19\u1A1A\u1A1B\u1B04\u1B35\u1B3B\u1B3D\u1B3E\u1B3F\u1B40\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1C24\u1C25\u1C26\u1C27\u1C28\u1C29\u1C2A\u1C2B\u1C34\u1C35\uA823\uA824\uA827\uA880\uA881\uA8B4\uA8B5\uA8B6\uA8B7\uA8B8\uA8B9\uA8BA\uA8BB\uA8BC\uA8BD\uA8BE\uA8BF\uA8C0\uA8C1\uA8C2\uA8C3\uA952\uA953\uAA2F\uAA30\uAA33\uAA34\uAA4D]

// Mark, Nonspacing
Mn = [\u0300\u0301\u0302\u0303\u0304\u0305\u0306\u0307\u0308\u0309\u030A\u030B\u030C\u030D\u030E\u030F\u0310\u0311\u0312\u0313\u0314\u0315\u0316\u0317\u0318\u0319\u031A\u031B\u031C\u031D\u031E\u031F\u0320\u0321\u0322\u0323\u0324\u0325\u0326\u0327\u0328\u0329\u032A\u032B\u032C\u032D\u032E\u032F\u0330\u0331\u0332\u0333\u0334\u0335\u0336\u0337\u0338\u0339\u033A\u033B\u033C\u033D\u033E\u033F\u0340\u0341\u0342\u0343\u0344\u0345\u0346\u0347\u0348\u0349\u034A\u034B\u034C\u034D\u034E\u034F\u0350\u0351\u0352\u0353\u0354\u0355\u0356\u0357\u0358\u0359\u035A\u035B\u035C\u035D\u035E\u035F\u0360\u0361\u0362\u0363\u0364\u0365\u0366\u0367\u0368\u0369\u036A\u036B\u036C\u036D\u036E\u036F\u0483\u0484\u0485\u0486\u0487\u0591\u0592\u0593\u0594\u0595\u0596\u0597\u0598\u0599\u059A\u059B\u059C\u059D\u059E\u059F\u05A0\u05A1\u05A2\u05A3\u05A4\u05A5\u05A6\u05A7\u05A8\u05A9\u05AA\u05AB\u05AC\u05AD\u05AE\u05AF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610\u0611\u0612\u0613\u0614\u0615\u0616\u0617\u0618\u0619\u061A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\u0653\u0654\u0655\u0656\u0657\u0658\u0659\u065A\u065B\u065C\u065D\u065E\u0670\u06D6\u06D7\u06D8\u06D9\u06DA\u06DB\u06DC\u06DF\u06E0\u06E1\u06E2\u06E3\u06E4\u06E7\u06E8\u06EA\u06EB\u06EC\u06ED\u0711\u0730\u0731\u0732\u0733\u0734\u0735\u0736\u0737\u0738\u0739\u073A\u073B\u073C\u073D\u073E\u073F\u0740\u0741\u0742\u0743\u0744\u0745\u0746\u0747\u0748\u0749\u074A\u07A6\u07A7\u07A8\u07A9\u07AA\u07AB\u07AC\u07AD\u07AE\u07AF\u07B0\u07EB\u07EC\u07ED\u07EE\u07EF\u07F0\u07F1\u07F2\u07F3\u0901\u0902\u093C\u0941\u0942\u0943\u0944\u0945\u0946\u0947\u0948\u094D\u0951\u0952\u0953\u0954\u0962\u0963\u0981\u09BC\u09C1\u09C2\u09C3\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1\u0AC2\u0AC3\u0AC4\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41\u0B42\u0B43\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E\u0C3F\u0C40\u0C46\u0C47\u0C48\u0C4A\u0C4B\u0C4C\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41\u0D42\u0D43\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2\u0DD3\u0DD4\u0DD6\u0E31\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0EB1\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBB\u0EBC\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71\u0F72\u0F73\u0F74\u0F75\u0F76\u0F77\u0F78\u0F79\u0F7A\u0F7B\u0F7C\u0F7D\u0F7E\u0F80\u0F81\u0F82\u0F83\u0F84\u0F86\u0F87\u0F90\u0F91\u0F92\u0F93\u0F94\u0F95\u0F96\u0F97\u0F99\u0F9A\u0F9B\u0F9C\u0F9D\u0F9E\u0F9F\u0FA0\u0FA1\u0FA2\u0FA3\u0FA4\u0FA5\u0FA6\u0FA7\u0FA8\u0FA9\u0FAA\u0FAB\u0FAC\u0FAD\u0FAE\u0FAF\u0FB0\u0FB1\u0FB2\u0FB3\u0FB4\u0FB5\u0FB6\u0FB7\u0FB8\u0FB9\u0FBA\u0FBB\u0FBC\u0FC6\u102D\u102E\u102F\u1030\u1032\u1033\u1034\u1035\u1036\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E\u105F\u1060\u1071\u1072\u1073\u1074\u1082\u1085\u1086\u108D\u135F\u1712\u1713\u1714\u1732\u1733\u1734\u1752\u1753\u1772\u1773\u17B7\u17B8\u17B9\u17BA\u17BB\u17BC\u17BD\u17C6\u17C9\u17CA\u17CB\u17CC\u17CD\u17CE\u17CF\u17D0\u17D1\u17D2\u17D3\u17DD\u180B\u180C\u180D\u18A9\u1920\u1921\u1922\u1927\u1928\u1932\u1939\u193A\u193B\u1A17\u1A18\u1B00\u1B01\u1B02\u1B03\u1B34\u1B36\u1B37\u1B38\u1B39\u1B3A\u1B3C\u1B42\u1B6B\u1B6C\u1B6D\u1B6E\u1B6F\u1B70\u1B71\u1B72\u1B73\u1B80\u1B81\u1BA2\u1BA3\u1BA4\u1BA5\u1BA8\u1BA9\u1C2C\u1C2D\u1C2E\u1C2F\u1C30\u1C31\u1C32\u1C33\u1C36\u1C37\u1DC0\u1DC1\u1DC2\u1DC3\u1DC4\u1DC5\u1DC6\u1DC7\u1DC8\u1DC9\u1DCA\u1DCB\u1DCC\u1DCD\u1DCE\u1DCF\u1DD0\u1DD1\u1DD2\u1DD3\u1DD4\u1DD5\u1DD6\u1DD7\u1DD8\u1DD9\u1DDA\u1DDB\u1DDC\u1DDD\u1DDE\u1DDF\u1DE0\u1DE1\u1DE2\u1DE3\u1DE4\u1DE5\u1DE6\u1DFE\u1DFF\u20D0\u20D1\u20D2\u20D3\u20D4\u20D5\u20D6\u20D7\u20D8\u20D9\u20DA\u20DB\u20DC\u20E1\u20E5\u20E6\u20E7\u20E8\u20E9\u20EA\u20EB\u20EC\u20ED\u20EE\u20EF\u20F0\u2DE0\u2DE1\u2DE2\u2DE3\u2DE4\u2DE5\u2DE6\u2DE7\u2DE8\u2DE9\u2DEA\u2DEB\u2DEC\u2DED\u2DEE\u2DEF\u2DF0\u2DF1\u2DF2\u2DF3\u2DF4\u2DF5\u2DF6\u2DF7\u2DF8\u2DF9\u2DFA\u2DFB\u2DFC\u2DFD\u2DFE\u2DFF\u302A\u302B\u302C\u302D\u302E\u302F\u3099\u309A\uA66F\uA67C\uA67D\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA926\uA927\uA928\uA929\uA92A\uA92B\uA92C\uA92D\uA947\uA948\uA949\uA94A\uA94B\uA94C\uA94D\uA94E\uA94F\uA950\uA951\uAA29\uAA2A\uAA2B\uAA2C\uAA2D\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uFB1E\uFE00\uFE01\uFE02\uFE03\uFE04\uFE05\uFE06\uFE07\uFE08\uFE09\uFE0A\uFE0B\uFE0C\uFE0D\uFE0E\uFE0F\uFE20\uFE21\uFE22\uFE23\uFE24\uFE25\uFE26]

// Number, Decimal Digit
Nd = [\u0030\u0031\u0032\u0033\u0034\u0035\u0036\u0037\u0038\u0039\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u06F0\u06F1\u06F2\u06F3\u06F4\u06F5\u06F6\u06F7\u06F8\u06F9\u07C0\u07C1\u07C2\u07C3\u07C4\u07C5\u07C6\u07C7\u07C8\u07C9\u0966\u0967\u0968\u0969\u096A\u096B\u096C\u096D\u096E\u096F\u09E6\u09E7\u09E8\u09E9\u09EA\u09EB\u09EC\u09ED\u09EE\u09EF\u0A66\u0A67\u0A68\u0A69\u0A6A\u0A6B\u0A6C\u0A6D\u0A6E\u0A6F\u0AE6\u0AE7\u0AE8\u0AE9\u0AEA\u0AEB\u0AEC\u0AED\u0AEE\u0AEF\u0B66\u0B67\u0B68\u0B69\u0B6A\u0B6B\u0B6C\u0B6D\u0B6E\u0B6F\u0BE6\u0BE7\u0BE8\u0BE9\u0BEA\u0BEB\u0BEC\u0BED\u0BEE\u0BEF\u0C66\u0C67\u0C68\u0C69\u0C6A\u0C6B\u0C6C\u0C6D\u0C6E\u0C6F\u0CE6\u0CE7\u0CE8\u0CE9\u0CEA\u0CEB\u0CEC\u0CED\u0CEE\u0CEF\u0D66\u0D67\u0D68\u0D69\u0D6A\u0D6B\u0D6C\u0D6D\u0D6E\u0D6F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\u0F20\u0F21\u0F22\u0F23\u0F24\u0F25\u0F26\u0F27\u0F28\u0F29\u1040\u1041\u1042\u1043\u1044\u1045\u1046\u1047\u1048\u1049\u1090\u1091\u1092\u1093\u1094\u1095\u1096\u1097\u1098\u1099\u17E0\u17E1\u17E2\u17E3\u17E4\u17E5\u17E6\u17E7\u17E8\u17E9\u1810\u1811\u1812\u1813\u1814\u1815\u1816\u1817\u1818\u1819\u1946\u1947\u1948\u1949\u194A\u194B\u194C\u194D\u194E\u194F\u19D0\u19D1\u19D2\u19D3\u19D4\u19D5\u19D6\u19D7\u19D8\u19D9\u1B50\u1B51\u1B52\u1B53\u1B54\u1B55\u1B56\u1B57\u1B58\u1B59\u1BB0\u1BB1\u1BB2\u1BB3\u1BB4\u1BB5\u1BB6\u1BB7\u1BB8\u1BB9\u1C40\u1C41\u1C42\u1C43\u1C44\u1C45\u1C46\u1C47\u1C48\u1C49\u1C50\u1C51\u1C52\u1C53\u1C54\u1C55\u1C56\u1C57\u1C58\u1C59\uA620\uA621\uA622\uA623\uA624\uA625\uA626\uA627\uA628\uA629\uA8D0\uA8D1\uA8D2\uA8D3\uA8D4\uA8D5\uA8D6\uA8D7\uA8D8\uA8D9\uA900\uA901\uA902\uA903\uA904\uA905\uA906\uA907\uA908\uA909\uAA50\uAA51\uAA52\uAA53\uAA54\uAA55\uAA56\uAA57\uAA58\uAA59\uFF10\uFF11\uFF12\uFF13\uFF14\uFF15\uFF16\uFF17\uFF18\uFF19]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator

LineSeparator = 
    // ( _ ";" _ )+
    ( LineTerminatorSequence _ )+