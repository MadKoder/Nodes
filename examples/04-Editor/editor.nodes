structs:
	Vec2 :
		float x
		float y
	Vec3 :
		float x
		float y
		float z
	Color :
		float r
		float g
		float b
	State : 
		Color color
	Maybe<T> :
		subs :
			Just :
				T x
			None
	Ui : 
		subs :
			Group:
				list<Ui> children
				subs :
					HGroup
					VGroup
			Button :
				string desc
				signal click(string what)
				slot onClick(string what):
					self.click(what)
			TextInput :
				string desc
				signal set(string text)
				signal focus(int what)
				signal onBuilt()
				slot onChange(string text):
					self.set(text)
			Text :
				string txt
	ParamDecl :
		string	name
		string	type
	Expr :
		subs :
			Func :
				string			type
				list<Expr>		params
			Ref :
				list<string>	path
			LitExpr :
				subs :
					IntExpr :
						int x
					StrExpr :
						string str
	FuncDef :
		string	id
		list<ParamDecl>	inputs
		Expr	output
	StructDef :
		string	name
		list<ParamDecl>	fields
		list<StructDef>	subs
	Program :
		list<FuncDef>	functions
		list<StructDef>	structs
functions:
	join(list<string> strs, string sep)
		reduce
		(
			string accum, string elem -> strCat(strCat(accum, sep), elem),
			strs
		)
	split(string str, string sep)
		fold
		(
			list<string> accum, string elem -> 
				if elem == sep 
				then pushBack(accum, "")
				else 
				[
					if i == (length(accum) - 1) 
					then strCat(subStr, elem)
					else subStr
					for subStr, i in accum
				],
			strToList(str),
			[""]
		)
	addVec2(Vec2 v0, Vec2 v1)
		Vec2(v0.x + v1.x, v0.y + v1.y)
	subVec2(Vec2 v0, Vec2 v1)
		Vec2(v0.x - v1.x, v0.y - v1.y)
	ref txtIn(string txtNode)
		TextInput(txtNode, set => txtNode = text)
	matchFuncStr(string str)
		findAllMatches(re("(\\D(?:\\w*))\\(([^)]*)\\)"), str)
	matchNewFuncStr(string str)
		findAllMatches(re("(\\D(?:\\w*))\\("), str)
	getOrElse<T>(Maybe<T> m, T y)
		type m :
			Just<T> : m.x
			_ :  y
	strToExpr(string str)
		let :
			funcMatch = maybeAt(matchNewFuncStr(str), 0)
			intMatch = maybeAt(findAllMatches(re("^(\\d.*)$"), str), 0)
			strMatch = maybeAt(findAllMatches(re("^\"(.*)$"), str), 0)
		in 
			type funcMatch :
				# Just<regmatch> : Func(group1(funcMatch.x), [Ref([param]) for param in split(group2(funcMatch.x), ",")])
				Just<regmatch> : Func(group1(funcMatch.x), [])
				_ :  type intMatch :
					Just<regMatch> : IntExpr(strToInt(group1(intMatch.x)))
					_ :  type strMatch :
						Just<regMatch> : StrExpr(group1(strMatch.x))
						_ : Ref(split(str, "."))
	ref Ui exprToUi(Expr expr)
		type expr :
			Func : HGroup
				([
					VGroup
					([
						txtIn(expr.type),
						TextInput
						(
							"i",
							set => expr.params = pushBack
								(
									expr.params,
									strToExpr(text)
								),
							onBuilt =>
								self.focus(self)
						)
					]),
					VGroup
					([
						exprToUi(param)
						for param in expr.params
					])
				])
			Ref : TextInput
				(
					join(expr.path, "."),
					set => expr = strToExpr(text)						
				)				
			IntExpr : TextInput
				(
					intToStr(expr.x),
					set => expr = strToExpr(text)
				)
			StrExpr : TextInput
				(
					expr.str,
					set => expr = strToExpr(text)
				)
			_ : TextInput("")
	# ref Ui exprToUi(Expr expr)
	# 	type expr :
	# 		Func :  HGroup([TextInput(expr.type, set => expr.type = text)])
	# 		_ : TextInput("")
	ref Ui funcToUi(FuncDef func)
		VGroup
		([
			txtIn(func.id),
			HGroup
			([
				VGroup(concat
				(
					concat
					(
						[Text("params")],
						[
							HGroup
							([
									txtIn(paramDecl.type),
									txtIn(paramDecl.name)
							])
							for paramDecl in func.inputs
						]
					),
					[Button
					(
						"Add input",
						click => 
							func.inputs = pushBack(func.inputs, ParamDecl("name", "type"))
					)]
				)),
				exprToUi(func.output)
			])
		])
	ref Ui progToUi(Program prog)
		VGroup
		([
			funcToUi(func) for func in prog.functions
			#exprToUi(func.output) for func in prog.functions
		])
nodes:
	var m = Just(1)
	var uiCounter = 0
	var program = Program :
		[]
		[]
	cache ui = progToUi(program)
	cache view = ui
	def uiView = UiView(ui)
	def uiView2 = UiView(ui)
	var toto = "toto"
	def txt = TextInput(toto, set => toto = text)
	# cache test = RootView(VGroupView(VGroup([]), "", [], ui, [TextInputView(txt, "VGroup", [], ui)]))
	# def test2 = TextInputView(txt, "", [], ui)

actions :
	# tick :
	# 	program = program \ functions = pushFront(program.functions, FuncDef("fun2"))
