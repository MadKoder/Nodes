structs:
	Vec2 :
		float x
		float y
	Vec3 :
		float x
		float y
		float z
	Color :
		float r
		float g
		float b
	State : 
		Color color
	Maybe<T> :
		subs :
			Just :
				T x
			None
	Ui : 
		subs :
			Group:
				list<Ui> children	
				bool	folded			
				subs :
					HGroup
					VGroup
			Button :
				string desc
				string image
				signal click(string what)
				slot onClick(string what):
					self.click(what)
			TextInput :
				string desc
				signal set(string text)
				signal focus(int what)
				signal onBuilt()
				slot onChange(string text):
					self.set(text)
				subs : 
					FocusTextInput :
						int 	focusCounter
			Text :
				string txt
	UiStore :
		bool	folded
		int 	focusCounter
	TypeDecl :
		string	name
		subs :
			Parametric :
				list<TypeDecl>	params
	ParamDecl :
		string		name
		TypeDecl	type
	Expr :
		subs :
			Func :
				string			type
				list<Expr>		params
			Ref :
				list<string>	path
			LitExpr :
				subs :
					IntExpr :
						int x
					StrExpr :
						string str
	FuncDef :
		string	id
		list<ParamDecl>	inputs
		Expr	output
	StructDef :
		string	name
		list<ParamDecl>	fields
		list<StructDef>	subStructs
	Program :
		list<FuncDef>	functions
		list<StructDef>	structs
functions:
	ref mHGroup(list<Ui> children)
		HGroup(children, false)
	ref mVGroup(list<Ui> children)
		VGroup(children, false)
	ref mButton2(string desc)
		Button(desc, "")
	ref mButton(string desc)
		mButton2(desc, click => loc a = 1)
	join(list<string> strs, string sep)
		reduce
		(
			string accum, string elem -> strCat(strCat(accum, sep), elem),
			strs
		)
	split(string str, string sep)
		fold
		(
			list<string> accum, string elem -> 
				if elem == sep 
				then pushBack(accum, "")
				else 
				[
					if i == (length(accum) - 1) 
					then strCat(subStr, elem)
					else subStr
					for subStr, i in accum
				],
			strToList(str),
			[""]
		)
	addVec2(Vec2 v0, Vec2 v1)
		Vec2(v0.x + v1.x, v0.y + v1.y)
	subVec2(Vec2 v0, Vec2 v1)
		Vec2(v0.x - v1.x, v0.y - v1.y)
	ref txtIn(string txtNode)
		TextInput(txtNode, set => txtNode = text)
	matchFuncStr(string str)
		findAllMatches(re("(\\D(?:\\w*))\\(([^)]*)\\)"), str)
	matchNewFuncStr(string str)
		findAllMatches(re("(\\D(?:\\w*))\\("), str)
	getOrElse<T>(Maybe<T> m, T y)
		type m :
			Just<T> : m.x
			_ :  y
	Expr strToExpr(string str)
		let :
			funcMatch = maybeAt(matchNewFuncStr(str), 0)
			intMatch = maybeAt(findAllMatches(re("^(\\d.*)$"), str), 0)
			strMatch = maybeAt(findAllMatches(re("^\"(.*)$"), str), 0)
		in 
			type funcMatch :
				# Just<regmatch> : Func(group1(funcMatch.x), [Ref([param]) for param in split(group2(funcMatch.x), ",")])
				Just<regmatch> : Func(group1(funcMatch.x), [])
				_ :  type intMatch :
					Just<regmatch> : IntExpr(strToInt(group1(intMatch.x)))
					_ :  type strMatch :
						Just<regmatch> : StrExpr(group1(strMatch.x))
						_ : Ref(split(str, "."))
	ref Ui exprToUi(Expr expr, int viewId, int focusCounter)
		let
			stored = expr.__views[viewId]
		in type expr :
			Func : mHGroup
				([
					mVGroup
					([
						mButton
						(
							type stored :
								Just<UiStore> : if stored.x.folded then "Unfold" else "Fold"
								_ : "Fold"
							,
							click => expr.__views[viewId] = type stored :
								Just<UiStore> : stored.x \ folded = if stored.x.folded then false else true
								_ : UiStore(true, 0)
						),
						txtIn(expr.type),
						FocusTextInput
						(
							"i"
							,type stored :
								Just<UiStore> : stored.x.focusCounter
								_ : 0
							,set => 
								loc newExpr = strToExpr(text)
								type newExpr do :
									Func => 
										newExpr.__views[viewId] = UiStore(false, focusCounter)
										focusCounter = focusCounter + 1
								# loc newUi = exprToUi(newExpr, viewId, focusCounter)
								# loc a = newUi.__id
								# globalFocus = newUi.__id
								# newExpr.__views[viewId] = newUi
								expr.params = pushBack
									(
										expr.params,
										newExpr
									)
							# ,	onBuilt =>
							# 	self.focus(self)
						)
					]),
					VGroup
					(
						[
							mHGroup
							([
								exprToUi(param, viewId, focusCounter),
								mButton
								(
									"Remove",
									click => expr.params = remove(expr.params, i)
								)
							])
							# exprToUi(param)
							for param, i in expr.params
						],
						type stored :
							Just<UiStore> : stored.x.folded
							_ : false
					)
				])
			Ref : TextInput
				(
					join(expr.path, "."),
					set => expr = strToExpr(text)						
				)				
			IntExpr : TextInput
				(
					intToStr(expr.x),
					set => expr = strToExpr(text)
				)
			StrExpr : TextInput
				(
					expr.str,
					set => expr = strToExpr(text)
				)
			_ : TextInput("")
	# ref Ui exprToUi(Expr expr)
	# 	type expr :
	# 		Func :  mHGroup([TextInput(expr.type, set => expr.type = text)])
	# 		_ : TextInput("")
	ref Ui typeDeclToUi(TypeDecl typeDecl, int viewId, int focusCounter)
		type typeDecl:
			Parametric : mHGroup
				([
					txtIn(typeDecl.name),
					mHGroup
					([
						mVGroup
						([
							typeDeclToUi(typeParam, viewId, focusCounter),
							mButton
							(
								"Remove",
								click => typeDecl.params = remove(typeDecl.params, i)
							)
						])
						for typeParam, i in typeDecl.params
					])
				])
			_ : txtIn(typeDecl.name)		
	ref paramsDeclToUi(list<ParamDecl> paramsDecl, int viewId, int focusCounter)
		mVGroup
		([
			mHGroup
			([
					typeDeclToUi(paramDecl.type, viewId, focusCounter),
					txtIn(paramDecl.name)
			])
			for paramDecl in paramsDecl
		])
	ref Ui funcToUi(FuncDef func, int viewId, int focusCounter)
		mVGroup
		([
			txtIn(func.id),
			mHGroup
			([
				mVGroup
				([
					Text("params"),
					paramsDeclToUi(func.inputs, viewId, focusCounter),
					mButton
					(
						"Add input",
						click => 
							func.inputs = pushBack
								(
									func.inputs, 
									ParamDecl("name", TypeDecl("type"))
								)
					)
				]),
				exprToUi(func.output, viewId, focusCounter)
			])
		])
	ref Ui structToUi(StructDef struct, int viewId, int focusCounter)
		mVGroup
		([
			txtIn(struct.name),
			paramsDeclToUi(struct.fields, viewId, focusCounter),
			Text(if length(struct.subStructs) > 0 then "Subs :" else "_"),
			mVGroup
			([
				structToUi(subStruct, viewId, focusCounter) for subStruct in struct.subStructs
			])
		])
	ref Ui progToUi(Program prog, int viewId, int focusCounter)
		# mVGroup([
		# 		funcToUi(func) for func in prog.functions
		# 	])
		mVGroup
		([
			mVGroup([
				funcToUi(func, viewId, focusCounter) for func in prog.functions
			]),
			mVGroup
			([
				structToUi(struct, viewId, focusCounter) for struct in prog.structs
			])
		])
nodes:
	var m = Just(1)
	var uiCounter = 0
	var program = Program :
		[]
		[]
	vat focusCounter = 1
	cache ui = progToUi(program, 0, focusCounter)
	cache ui1 = progToUi(program, 1, focusCounter)
	cache view = ui
	def uiView = UiView(ui)
	def uiView2 = UiView(ui1)
	var toto = "toto"
	def txt = TextInput(toto, set => toto = text)
	# cache test = RootView(VGroupView(mVGroup([]), "", [], ui, [TextInputView(txt, "mVGroup", [], ui)]))
	# def test2 = TextInputView(txt, "", [], ui)

actions :
	# tick :
	# 	program = program \ functions = pushFront(program.functions, FuncDef("fun2"))
