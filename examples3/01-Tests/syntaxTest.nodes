
fun f x:int (y:int=0) :: int =
	x + y

fun g x = f x

signal<T> : ()=>T
slot<T> : T=>()
gen<T,U> : T=>U

signal text :: string =
	input
	=> debounce 300
	=> map (fun evt => evt.target.value)
	=> skipDuplicates

type text == () => string

gen testGen x => x + 1
type testGen == int => int

gen testGen x :: int do return x + 1

gen testGen x :: int do 
	return x + 1

gen testGen2 x :: int do 
	return testGen x

gen pipeGen x 
	=> testGen
	=> testGen

type pipeGen == int => int

gen gen2 x y => x + y
type gen2 == int => int => int

gen pipeGen2 x
	=> gen2 10

slot testSlot y do x = y

slot pipeSlot y
	=> testSlot

slot pipeSlot2 (x, y)
	==> gen2
	=> testSlot

gen gen2Bis (x y) => x + y
type gen2 == int * int => int

slot pipeSlot2Bis (x, y)
	=> gen2Bis
	=> testSlot

signal sig :: int

slot slt x : int do
	y = x

sig => slt

gen movieSearch query:string :: list<string> do
	if len(query) < 3 then
		return signalOnce<list<string>>([])
	return fromPromise(queryMovie(query))

signal suggestions :: list<int> =
	text
	=> flatMapLatest movieSearch

gen awaiting<T> awaiter:signal<T> awaited:signal<T> :: ref<T> do
	return new prop {
		var val : bool = true
		on awaiter do
			val = true
		on awaited do
			val = false
	}


prop awaitSuggestions : bool = awaiting text suggestions

on awaitSuggestions became true do
	$(results).html("searching...")

on suggestions do
	$(results).html(map showMovie results)	

slot tick() do x = y
slot tick() do
	x = y
slot tick() do
	x = y
	z = u
slot tick() do
	x = if a 
		then b
		else if c  # comment
			then d
			else e
	z = u
slot tick() do {
	x = y
	z = u
}
slot tick() do {
}
slot tick() do {x = y; z = u}